# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 0.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import re  # noqa: F401
import warnings

from typing import Any, Dict, Optional

from pydantic import (
    conlist,
    constr,
    Field,
    StrictInt,
    StrictStr,
    validate_arguments,
    ValidationError,
    validator,
)
from typing_extensions import Annotated

from gretel_client.rest_v1.api_client import ApiClient
from gretel_client.rest_v1.api_response import ApiResponse
from gretel_client.rest_v1.exceptions import ApiTypeError, ApiValueError  # noqa: F401
from gretel_client.rest_v1.models.create_workflow_request import CreateWorkflowRequest
from gretel_client.rest_v1.models.create_workflow_run_request import (
    CreateWorkflowRunRequest,
)
from gretel_client.rest_v1.models.get_workflows_response import GetWorkflowsResponse
from gretel_client.rest_v1.models.search_workflow_runs_response import (
    SearchWorkflowRunsResponse,
)
from gretel_client.rest_v1.models.search_workflow_tasks_response import (
    SearchWorkflowTasksResponse,
)
from gretel_client.rest_v1.models.search_workflows_response import (
    SearchWorkflowsResponse,
)
from gretel_client.rest_v1.models.validate_workflow_action_response import (
    ValidateWorkflowActionResponse,
)
from gretel_client.rest_v1.models.validate_workflow_config_request import (
    ValidateWorkflowConfigRequest,
)
from gretel_client.rest_v1.models.workflow import Workflow
from gretel_client.rest_v1.models.workflow_run import WorkflowRun
from gretel_client.rest_v1.models.workflow_task import WorkflowTask


class WorkflowsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def cancel_workflow_run(
        self,
        workflow_run_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow run to cancel."),
        ],
        **kwargs,
    ) -> WorkflowRun:  # noqa: E501
        """cancel_workflow_run  # noqa: E501

        Cancel a workflow run.  This endpoint is used to cancel a workflow run. This will stop the workflow run and transition it to a `cancelled` state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_workflow_run(workflow_run_id, async_req=True)
        >>> result = thread.get()

        :param workflow_run_id: The ID of the workflow run to cancel. (required)
        :type workflow_run_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowRun
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the cancel_workflow_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.cancel_workflow_run_with_http_info(
            workflow_run_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def cancel_workflow_run_with_http_info(
        self,
        workflow_run_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow run to cancel."),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """cancel_workflow_run  # noqa: E501

        Cancel a workflow run.  This endpoint is used to cancel a workflow run. This will stop the workflow run and transition it to a `cancelled` state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_workflow_run_with_http_info(workflow_run_id, async_req=True)
        >>> result = thread.get()

        :param workflow_run_id: The ID of the workflow run to cancel. (required)
        :type workflow_run_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowRun, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["workflow_run_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_workflow_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["workflow_run_id"]:
            _path_params["workflow_run_id"] = _params["workflow_run_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "WorkflowRun",
        }

        return self.api_client.call_api(
            "/v1/workflows/runs/{workflow_run_id}/cancel",
            "PATCH",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_workflow(
        self, create_workflow_request: CreateWorkflowRequest, **kwargs
    ) -> Workflow:  # noqa: E501
        """create_workflow  # noqa: E501

        Create a new workflow in the provided project.  Providing a config is optional, but workflow runs created from this workflow will require a config be provided.  Config can be provided as an object or as a YAML string. String configs will preserve comments and formatting where object configs cannot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_workflow(create_workflow_request, async_req=True)
        >>> result = thread.get()

        :param create_workflow_request: (required)
        :type create_workflow_request: CreateWorkflowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Workflow
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the create_workflow_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.create_workflow_with_http_info(
            create_workflow_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_workflow_with_http_info(
        self, create_workflow_request: CreateWorkflowRequest, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """create_workflow  # noqa: E501

        Create a new workflow in the provided project.  Providing a config is optional, but workflow runs created from this workflow will require a config be provided.  Config can be provided as an object or as a YAML string. String configs will preserve comments and formatting where object configs cannot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_workflow_with_http_info(create_workflow_request, async_req=True)
        >>> result = thread.get()

        :param create_workflow_request: (required)
        :type create_workflow_request: CreateWorkflowRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Workflow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["create_workflow_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workflow" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_workflow_request"] is not None:
            _body_params = _params["create_workflow_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Workflow",
        }

        return self.api_client.call_api(
            "/v1/workflows",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_workflow_run(
        self, create_workflow_run_request: CreateWorkflowRunRequest, **kwargs
    ) -> WorkflowRun:  # noqa: E501
        """create_workflow_run  # noqa: E501

        Create a new workflow run for a given workflow.  Providing a config is optional, but the workflow run will require a config be provided.  Config can be provided as an object or as a YAML string. String configs will preserve comments and formatting where object configs cannot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_workflow_run(create_workflow_run_request, async_req=True)
        >>> result = thread.get()

        :param create_workflow_run_request: (required)
        :type create_workflow_run_request: CreateWorkflowRunRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowRun
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the create_workflow_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.create_workflow_run_with_http_info(
            create_workflow_run_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_workflow_run_with_http_info(
        self, create_workflow_run_request: CreateWorkflowRunRequest, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """create_workflow_run  # noqa: E501

        Create a new workflow run for a given workflow.  Providing a config is optional, but the workflow run will require a config be provided.  Config can be provided as an object or as a YAML string. String configs will preserve comments and formatting where object configs cannot.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_workflow_run_with_http_info(create_workflow_run_request, async_req=True)
        >>> result = thread.get()

        :param create_workflow_run_request: (required)
        :type create_workflow_run_request: CreateWorkflowRunRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowRun, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["create_workflow_run_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_workflow_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["create_workflow_run_request"] is not None:
            _body_params = _params["create_workflow_run_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "WorkflowRun",
        }

        return self.api_client.call_api(
            "/v1/workflows/runs",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def delete_workflow(
        self,
        workflow_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow to delete."),
        ],
        **kwargs,
    ) -> None:  # noqa: E501
        """delete_workflow  # noqa: E501

        Delete a workflow by ID.  This will also delete all associated workflow runs and tasks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflow(workflow_id, async_req=True)
        >>> result = thread.get()

        :param workflow_id: The ID of the workflow to delete. (required)
        :type workflow_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the delete_workflow_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.delete_workflow_with_http_info(workflow_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_workflow_with_http_info(
        self,
        workflow_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow to delete."),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """delete_workflow  # noqa: E501

        Delete a workflow by ID.  This will also delete all associated workflow runs and tasks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_workflow_with_http_info(workflow_id, async_req=True)
        >>> result = thread.get()

        :param workflow_id: The ID of the workflow to delete. (required)
        :type workflow_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["workflow_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_workflow" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["workflow_id"]:
            _path_params["workflow_id"] = _params["workflow_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/v1/workflows/{workflow_id}",
            "DELETE",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_workflow(
        self,
        workflow_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow to retrieve."),
        ],
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the response. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`"
            ),
        ] = None,
        **kwargs,
    ) -> Workflow:  # noqa: E501
        """get_workflow  # noqa: E501

        Get a single workflow by ID.  This endpoint supports expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow(workflow_id, expand, async_req=True)
        >>> result = thread.get()

        :param workflow_id: The ID of the workflow to retrieve. (required)
        :type workflow_id: str
        :param expand: The fields to expand in the response. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Workflow
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_workflow_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.get_workflow_with_http_info(
            workflow_id, expand, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_workflow_with_http_info(
        self,
        workflow_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow to retrieve."),
        ],
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the response. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """get_workflow  # noqa: E501

        Get a single workflow by ID.  This endpoint supports expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_with_http_info(workflow_id, expand, async_req=True)
        >>> result = thread.get()

        :param workflow_id: The ID of the workflow to retrieve. (required)
        :type workflow_id: str
        :param expand: The fields to expand in the response. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Workflow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["workflow_id", "expand"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["workflow_id"]:
            _path_params["workflow_id"] = _params["workflow_id"]

        # process the query parameters
        _query_params = []
        if _params.get("expand") is not None:  # noqa: E501
            _query_params.append(("expand", _params["expand"]))
            _collection_formats["expand"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Workflow",
        }

        return self.api_client.call_api(
            "/v1/workflows/{workflow_id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_workflow_run(
        self,
        workflow_run_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow run to retrieve."),
        ],
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the response. Supported values are: `project`, `config.system`, `created_by`"
            ),
        ] = None,
        **kwargs,
    ) -> WorkflowRun:  # noqa: E501
        """get_workflow_run  # noqa: E501

        Get a single workflow run by ID.  This endpoint supports expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_run(workflow_run_id, expand, async_req=True)
        >>> result = thread.get()

        :param workflow_run_id: The ID of the workflow run to retrieve. (required)
        :type workflow_run_id: str
        :param expand: The fields to expand in the response. Supported values are: `project`, `config.system`, `created_by`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowRun
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_workflow_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.get_workflow_run_with_http_info(
            workflow_run_id, expand, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_workflow_run_with_http_info(
        self,
        workflow_run_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow run to retrieve."),
        ],
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the response. Supported values are: `project`, `config.system`, `created_by`"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """get_workflow_run  # noqa: E501

        Get a single workflow run by ID.  This endpoint supports expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_run_with_http_info(workflow_run_id, expand, async_req=True)
        >>> result = thread.get()

        :param workflow_run_id: The ID of the workflow run to retrieve. (required)
        :type workflow_run_id: str
        :param expand: The fields to expand in the response. Supported values are: `project`, `config.system`, `created_by`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowRun, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["workflow_run_id", "expand"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_run" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["workflow_run_id"]:
            _path_params["workflow_run_id"] = _params["workflow_run_id"]

        # process the query parameters
        _query_params = []
        if _params.get("expand") is not None:  # noqa: E501
            _query_params.append(("expand", _params["expand"]))
            _collection_formats["expand"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "WorkflowRun",
        }

        return self.api_client.call_api(
            "/v1/workflows/runs/{workflow_run_id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_workflow_task(
        self,
        workflow_task_id: Annotated[
            StrictStr,
            Field(..., description="The ID of the workflow task to retrieve."),
        ],
        **kwargs,
    ) -> WorkflowTask:  # noqa: E501
        """get_workflow_task  # noqa: E501

        Get a single workflow task by ID.  This endpoint supports expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_task(workflow_task_id, async_req=True)
        >>> result = thread.get()

        :param workflow_task_id: The ID of the workflow task to retrieve. (required)
        :type workflow_task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: WorkflowTask
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_workflow_task_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.get_workflow_task_with_http_info(
            workflow_task_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_workflow_task_with_http_info(
        self,
        workflow_task_id: Annotated[
            StrictStr,
            Field(..., description="The ID of the workflow task to retrieve."),
        ],
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """get_workflow_task  # noqa: E501

        Get a single workflow task by ID.  This endpoint supports expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflow_task_with_http_info(workflow_task_id, async_req=True)
        >>> result = thread.get()

        :param workflow_task_id: The ID of the workflow task to retrieve. (required)
        :type workflow_task_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(WorkflowTask, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["workflow_task_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflow_task" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["workflow_task_id"]:
            _path_params["workflow_task_id"] = _params["workflow_task_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "WorkflowTask",
        }

        return self.api_client.call_api(
            "/v1/workflows/runs/tasks/{workflow_task_id}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_workflows(self, **kwargs) -> GetWorkflowsResponse:  # noqa: E501
        """get_workflows  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetWorkflowsResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the get_workflows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.get_workflows_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def get_workflows_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """get_workflows  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_workflows_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetWorkflowsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = []
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_workflows" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "GetWorkflowsResponse",
        }

        return self.api_client.call_api(
            "/v1/workflows",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def search_workflow_runs(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="The query string for searching workflow runs. Supported fields are: `id`, `workflow_id`, `project_id`, `status`, `runner_mode`, `cancelation_request`"
            ),
        ] = None,
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the search results. Supported values are: `project`, `config.system`, `created_by`"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="The maximum number of results to return."),
        ] = None,
        skip: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of results to skip before applying the limit."
            ),
        ] = None,
        sort: Annotated[
            Optional[StrictStr],
            Field(description="The sort order for the search results."),
        ] = None,
        **kwargs,
    ) -> SearchWorkflowRunsResponse:  # noqa: E501
        """search_workflow_runs  # noqa: E501

        Search for workflow runs.  This endpoint supports pagination, querying, and expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_workflow_runs(query, expand, limit, skip, sort, async_req=True)
        >>> result = thread.get()

        :param query: The query string for searching workflow runs. Supported fields are: `id`, `workflow_id`, `project_id`, `status`, `runner_mode`, `cancelation_request`
        :type query: str
        :param expand: The fields to expand in the search results. Supported values are: `project`, `config.system`, `created_by`
        :type expand: List[str]
        :param limit: The maximum number of results to return.
        :type limit: int
        :param skip: The number of results to skip before applying the limit.
        :type skip: int
        :param sort: The sort order for the search results.
        :type sort: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchWorkflowRunsResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the search_workflow_runs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.search_workflow_runs_with_http_info(
            query, expand, limit, skip, sort, **kwargs
        )  # noqa: E501

    @validate_arguments
    def search_workflow_runs_with_http_info(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="The query string for searching workflow runs. Supported fields are: `id`, `workflow_id`, `project_id`, `status`, `runner_mode`, `cancelation_request`"
            ),
        ] = None,
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the search results. Supported values are: `project`, `config.system`, `created_by`"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="The maximum number of results to return."),
        ] = None,
        skip: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of results to skip before applying the limit."
            ),
        ] = None,
        sort: Annotated[
            Optional[StrictStr],
            Field(description="The sort order for the search results."),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """search_workflow_runs  # noqa: E501

        Search for workflow runs.  This endpoint supports pagination, querying, and expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_workflow_runs_with_http_info(query, expand, limit, skip, sort, async_req=True)
        >>> result = thread.get()

        :param query: The query string for searching workflow runs. Supported fields are: `id`, `workflow_id`, `project_id`, `status`, `runner_mode`, `cancelation_request`
        :type query: str
        :param expand: The fields to expand in the search results. Supported values are: `project`, `config.system`, `created_by`
        :type expand: List[str]
        :param limit: The maximum number of results to return.
        :type limit: int
        :param skip: The number of results to skip before applying the limit.
        :type skip: int
        :param sort: The sort order for the search results.
        :type sort: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchWorkflowRunsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["query", "expand", "limit", "skip", "sort"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow_runs" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("query") is not None:  # noqa: E501
            _query_params.append(("query", _params["query"]))

        if _params.get("expand") is not None:  # noqa: E501
            _query_params.append(("expand", _params["expand"]))
            _collection_formats["expand"] = "multi"

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("skip") is not None:  # noqa: E501
            _query_params.append(("skip", _params["skip"]))

        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "SearchWorkflowRunsResponse",
        }

        return self.api_client.call_api(
            "/v1/workflows/runs/search",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def search_workflow_tasks(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="The query string for searching workflow tasks. Supported fields are: `workflow_run_id`"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="The maximum number of results to return."),
        ] = None,
        skip: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of results to skip before applying the limit."
            ),
        ] = None,
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the search results. Supported values are: `project`, `created_by`"
            ),
        ] = None,
        **kwargs,
    ) -> SearchWorkflowTasksResponse:  # noqa: E501
        """search_workflow_tasks  # noqa: E501

        Search for workflow tasks.  This endpoint supports pagination, querying, and expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_workflow_tasks(query, limit, skip, expand, async_req=True)
        >>> result = thread.get()

        :param query: The query string for searching workflow tasks. Supported fields are: `workflow_run_id`
        :type query: str
        :param limit: The maximum number of results to return.
        :type limit: int
        :param skip: The number of results to skip before applying the limit.
        :type skip: int
        :param expand: The fields to expand in the search results. Supported values are: `project`, `created_by`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchWorkflowTasksResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the search_workflow_tasks_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.search_workflow_tasks_with_http_info(
            query, limit, skip, expand, **kwargs
        )  # noqa: E501

    @validate_arguments
    def search_workflow_tasks_with_http_info(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="The query string for searching workflow tasks. Supported fields are: `workflow_run_id`"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="The maximum number of results to return."),
        ] = None,
        skip: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of results to skip before applying the limit."
            ),
        ] = None,
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the search results. Supported values are: `project`, `created_by`"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """search_workflow_tasks  # noqa: E501

        Search for workflow tasks.  This endpoint supports pagination, querying, and expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_workflow_tasks_with_http_info(query, limit, skip, expand, async_req=True)
        >>> result = thread.get()

        :param query: The query string for searching workflow tasks. Supported fields are: `workflow_run_id`
        :type query: str
        :param limit: The maximum number of results to return.
        :type limit: int
        :param skip: The number of results to skip before applying the limit.
        :type skip: int
        :param expand: The fields to expand in the search results. Supported values are: `project`, `created_by`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchWorkflowTasksResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["query", "limit", "skip", "expand"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflow_tasks" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("query") is not None:  # noqa: E501
            _query_params.append(("query", _params["query"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("skip") is not None:  # noqa: E501
            _query_params.append(("skip", _params["skip"]))

        if _params.get("expand") is not None:  # noqa: E501
            _query_params.append(("expand", _params["expand"]))
            _collection_formats["expand"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "SearchWorkflowTasksResponse",
        }

        return self.api_client.call_api(
            "/v1/workflows/runs/tasks/search",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def search_workflows(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="The query string for searching workflows. Supported fields are: `id`, `project_id`"
            ),
        ] = None,
        sort: Annotated[
            Optional[StrictStr],
            Field(description="The sort order for the search results."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="The maximum number of results to return."),
        ] = None,
        skip: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of results to skip before applying the limit."
            ),
        ] = None,
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the search results. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`"
            ),
        ] = None,
        **kwargs,
    ) -> SearchWorkflowsResponse:  # noqa: E501
        """search_workflows  # noqa: E501

        Search for workflows you or other project members have created.  This endpoint supports pagination, querying, and expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_workflows(query, sort, limit, skip, expand, async_req=True)
        >>> result = thread.get()

        :param query: The query string for searching workflows. Supported fields are: `id`, `project_id`
        :type query: str
        :param sort: The sort order for the search results.
        :type sort: str
        :param limit: The maximum number of results to return.
        :type limit: int
        :param skip: The number of results to skip before applying the limit.
        :type skip: int
        :param expand: The fields to expand in the search results. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SearchWorkflowsResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the search_workflows_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.search_workflows_with_http_info(
            query, sort, limit, skip, expand, **kwargs
        )  # noqa: E501

    @validate_arguments
    def search_workflows_with_http_info(
        self,
        query: Annotated[
            Optional[StrictStr],
            Field(
                description="The query string for searching workflows. Supported fields are: `id`, `project_id`"
            ),
        ] = None,
        sort: Annotated[
            Optional[StrictStr],
            Field(description="The sort order for the search results."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="The maximum number of results to return."),
        ] = None,
        skip: Annotated[
            Optional[StrictInt],
            Field(
                description="The number of results to skip before applying the limit."
            ),
        ] = None,
        expand: Annotated[
            Optional[conlist(StrictStr)],
            Field(
                description="The fields to expand in the search results. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`"
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """search_workflows  # noqa: E501

        Search for workflows you or other project members have created.  This endpoint supports pagination, querying, and expansion.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.search_workflows_with_http_info(query, sort, limit, skip, expand, async_req=True)
        >>> result = thread.get()

        :param query: The query string for searching workflows. Supported fields are: `id`, `project_id`
        :type query: str
        :param sort: The sort order for the search results.
        :type sort: str
        :param limit: The maximum number of results to return.
        :type limit: int
        :param skip: The number of results to skip before applying the limit.
        :type skip: int
        :param expand: The fields to expand in the search results. Supported values are: `project`, `created_by`, `updated_by`, `latest_run`
        :type expand: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SearchWorkflowsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["query", "sort", "limit", "skip", "expand"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_workflows" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("query") is not None:  # noqa: E501
            _query_params.append(("query", _params["query"]))

        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"]))

        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        if _params.get("skip") is not None:  # noqa: E501
            _query_params.append(("skip", _params["skip"]))

        if _params.get("expand") is not None:  # noqa: E501
            _query_params.append(("expand", _params["expand"]))
            _collection_formats["expand"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "SearchWorkflowsResponse",
        }

        return self.api_client.call_api(
            "/v1/workflows/search",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_workflow_config(
        self,
        workflow_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow to update."),
        ],
        body: StrictStr,
        **kwargs,
    ) -> Workflow:  # noqa: E501
        """update_workflow_config  # noqa: E501

        Update the config of an existing workflow.  Future runs will be created with this config, existing runs will keep the config they were created with.  Config can be provided as JSON or YAML content types. If provided as JSON, the `config_text` will be replaced with the JSON representation of the config, and any existing formatting or comments will be lost.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_workflow_config(workflow_id, body, async_req=True)
        >>> result = thread.get()

        :param workflow_id: The ID of the workflow to update. (required)
        :type workflow_id: str
        :param body: (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Workflow
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the update_workflow_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.update_workflow_config_with_http_info(
            workflow_id, body, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_workflow_config_with_http_info(
        self,
        workflow_id: Annotated[
            constr(strict=True),
            Field(..., description="The ID of the workflow to update."),
        ],
        body: StrictStr,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """update_workflow_config  # noqa: E501

        Update the config of an existing workflow.  Future runs will be created with this config, existing runs will keep the config they were created with.  Config can be provided as JSON or YAML content types. If provided as JSON, the `config_text` will be replaced with the JSON representation of the config, and any existing formatting or comments will be lost.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_workflow_config_with_http_info(workflow_id, body, async_req=True)
        >>> result = thread.get()

        :param workflow_id: The ID of the workflow to update. (required)
        :type workflow_id: str
        :param body: (required)
        :type body: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Workflow, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["workflow_id", "body"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_workflow_config" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["workflow_id"]:
            _path_params["workflow_id"] = _params["workflow_id"]

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "Workflow",
        }

        return self.api_client.call_api(
            "/v1/workflows/{workflow_id}/config",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def validate_workflow_action(
        self,
        body: Dict[str, Any],
        runner_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="The runner mode to validate the action for. If this field is not UNSET, take the runner mode (cloud or hybrid) into account. This primarily affects which connections can be used in an action; those with Gretel-managed credentials encryption can't be used in a Hybrid workflow, and vice versa."
            ),
        ] = None,
        **kwargs,
    ) -> ValidateWorkflowActionResponse:  # noqa: E501
        """validate_workflow_action  # noqa: E501

        Validate a single workflow action.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_workflow_action(body, runner_mode, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: object
        :param runner_mode: The runner mode to validate the action for. If this field is not UNSET, take the runner mode (cloud or hybrid) into account. This primarily affects which connections can be used in an action; those with Gretel-managed credentials encryption can't be used in a Hybrid workflow, and vice versa.
        :type runner_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ValidateWorkflowActionResponse
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the validate_workflow_action_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.validate_workflow_action_with_http_info(
            body, runner_mode, **kwargs
        )  # noqa: E501

    @validate_arguments
    def validate_workflow_action_with_http_info(
        self,
        body: Dict[str, Any],
        runner_mode: Annotated[
            Optional[StrictStr],
            Field(
                description="The runner mode to validate the action for. If this field is not UNSET, take the runner mode (cloud or hybrid) into account. This primarily affects which connections can be used in an action; those with Gretel-managed credentials encryption can't be used in a Hybrid workflow, and vice versa."
            ),
        ] = None,
        **kwargs,
    ) -> ApiResponse:  # noqa: E501
        """validate_workflow_action  # noqa: E501

        Validate a single workflow action.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_workflow_action_with_http_info(body, runner_mode, async_req=True)
        >>> result = thread.get()

        :param body: (required)
        :type body: object
        :param runner_mode: The runner mode to validate the action for. If this field is not UNSET, take the runner mode (cloud or hybrid) into account. This primarily affects which connections can be used in an action; those with Gretel-managed credentials encryption can't be used in a Hybrid workflow, and vice versa.
        :type runner_mode: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ValidateWorkflowActionResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["body", "runner_mode"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_workflow_action" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("runner_mode") is not None:  # noqa: E501
            _query_params.append(("runner_mode", _params["runner_mode"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["body"] is not None:
            _body_params = _params["body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            "200": "ValidateWorkflowActionResponse",
        }

        return self.api_client.call_api(
            "/v1/workflows/validate-action",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def validate_workflow_config(
        self, validate_workflow_config_request: ValidateWorkflowConfigRequest, **kwargs
    ) -> None:  # noqa: E501
        """validate_workflow_config  # noqa: E501

        Validate a workflow config.  This endpoint will validate a workflow config, returning a status and message indicating if the config is valid  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_workflow_config(validate_workflow_config_request, async_req=True)
        >>> result = thread.get()

        :param validate_workflow_config_request: (required)
        :type validate_workflow_config_request: ValidateWorkflowConfigRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        if "_preload_content" in kwargs:
            raise ValueError(
                "Error! Please call the validate_workflow_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
            )
        return self.validate_workflow_config_with_http_info(
            validate_workflow_config_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def validate_workflow_config_with_http_info(
        self, validate_workflow_config_request: ValidateWorkflowConfigRequest, **kwargs
    ) -> ApiResponse:  # noqa: E501
        """validate_workflow_config  # noqa: E501

        Validate a workflow config.  This endpoint will validate a workflow config, returning a status and message indicating if the config is valid  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.validate_workflow_config_with_http_info(validate_workflow_config_request, async_req=True)
        >>> result = thread.get()

        :param validate_workflow_config_request: (required)
        :type validate_workflow_config_request: ValidateWorkflowConfigRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["validate_workflow_config_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_workflow_config" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params["validate_workflow_config_request"] is not None:
            _body_params = _params["validate_workflow_config_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/v1/workflows/validate-config",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
